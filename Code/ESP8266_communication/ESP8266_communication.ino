/* GENERAL DESCRIPTION: this code allows the ESP-F (https://fccid.io/2AL3B-ESP-F/User-Manual/User-Manual-3387875) to communicate with our sensor. 
 * The purpose is to generate a frequency sweep with the AD5932 signal generator (https://www.analog.com/media/en/technical-documentation/data-sheets/AD5932.pdf)
 * and to read the output signal generated by our sensor. The ESP-F uses the SPI communication protocol to write the registers of the AD5932 and set the desired sweep 
 * characteristics (ex. start frequency, frequency step etc...). Note that the AD5932 can be programmed to generate a sweep automatically or to increase the frequency of one step
 * every time the CONTROL pin is toggled (see datasheet for more details). Here we use the second mode in order to have more control over the timing of the sweep, so we need to manually 
 * toggle the CONTROL pin to increase the frequency. Basically the code is an endless loop which does the following:
 * 1. send SPI commands to program AD5932
 * 2. toggle CONTROL pin 
 * 3. read voltage
 * 4. repeat points 2 and 3 until the end of the sweep is reached
 * 
 * Please note that the AD5932 must be reprogrammed at every iteration, otherwise the sweep wouldn't restart (maybe there's a more elegant way to do this, but this works).
 */


#include <SPI.h>
#include <ESP8266WiFi.h>
#include "ESPAsyncUDP.h"

/** EXTREMELY IMPORTANT!!! Replace these 3 parameters with those of your Wifi connection!**/
const char* ssid     = "Blum";                          // the name of the Wifi
const char* password = "Le seul chemin vers Dieu";      // the password of the wifi
#define IP_ADDRESS      IPAddress(192, 168, 22, 64)     // the IP address of the device to which we want to send the data
/** -----------------------------------------------------  **/


#define PIN_SYNC      12    // this pin should be held low during an SPI transmission, to signal the AD5932 that a transmission is happening. It must be raised afterwards to end the transmission
#define PIN_CONTROL   16    // every time this signal transitions from 0 to 1 the AD5932 increments the frequency of 1 step
#define PIN_VOUT      A0    // in the "ESP8266 Arduino Core" doc they say to use A0

#define N_DATA_POINTS             100       // the number of datapoints we want to collect (corresponds to the number of fequency increments)
#define MIN_ACQUISITION_TIME_MS   1        // after the frequency is incremented of 1 step, the code reads the output signal during this amount of time (at least) and averages the readings
#define SPI_FREQUENCY             2000     // (Hertzs) the frequency at which we should operate the SPI communication with the AD5932

#define PORT                5005                            // the port used to connect to the device that will receive the measurements
#define STRING_SEPARATOR    ' '                             // the ESP sends the values to the UDP client as a single string, so we need a symbol that acts as a separator between the values

AsyncUDP udp;                   // Variables for wifi connnection
AsyncUDP udp_listen;




void(* resetFunc) (void) = 0;

float datapoints[N_DATA_POINTS];    // the array where we will store the output received from the sensor

void setup_sweep();
void setup_UDP_connection();
String formatToString(float *array, int size, char separator);


void setup() {
  Serial.begin(115200);
  pinMode(PIN_VOUT, INPUT);       // set the ADC pin as input (called VOUT because it is connected to the VOUT pin of our circuit)
  pinMode(PIN_CONTROL, OUTPUT);
  pinMode(PIN_SYNC, OUTPUT);

  setup_UDP_connection();
}



void loop() {
  int i, n;
  String formatted_string = "";
  
  setup_sweep();  // programs the AD5932, the sweep will start on the first raising edge of the CONTROL signal

  // increments the frequency and reads the sensor output
  for(i=0; i<N_DATA_POINTS; i++)
  {
      int starting_time = millis();
      
      //toggles the control pin
      digitalWrite(PIN_CONTROL, HIGH);
      //delay(1);
      digitalWrite(PIN_CONTROL, LOW);

      // reads the output of the sensor for the desired time and averages the readings
      float sensor_voltage = 0;
      n = 0;
      do
      {
        n++;
        sensor_voltage += analogRead(PIN_VOUT)/1024.0;
      }while(millis()< starting_time + MIN_ACQUISITION_TIME_MS);
      sensor_voltage /= n;
      
      //Serial.println();
      //Serial.println(sensor_voltage);
      datapoints[i] = sensor_voltage;
  }

  formatted_string = formatToString(datapoints, N_DATA_POINTS, STRING_SEPARATOR);

  // send the measurement to the receiving device
  udp.print("s");                 // send start code
  delay(1);                       // IMPORTANT! not sure why but without delays the transmission doesn't work well
  udp.print(formatted_string);    // send data formatted into a single string
  delay(1);
  udp.print("e") ;                // send end code
}




//sends the SPI commands that setup the sweep
void setup_sweep()
{
  Serial.println("Sending SPI commands...");

  pinMode(PIN_SYNC, OUTPUT);  // sets the SYNC pin as output. NOTE! This must be done every time because starting the SPI communication sets this as input (becasue it is also the MISO pin of the SPI)
  digitalWrite(PIN_SYNC, LOW);  // lowers SYNC signal to tell the AD5932 that an SPI transfer has begun
  
  SPI.begin();
  SPI.beginTransaction(SPISettings(SPI_FREQUENCY, MSBFIRST, SPI_MODE1)); 

// control register
  SPI.transfer(0x06);
  SPI.transfer(0xF7);

// start frequency
  SPI.transfer(0xC7);
  SPI.transfer(0xAE);
  SPI.transfer(0xD0);
  SPI.transfer(0x14);

// frequency increment
  SPI.transfer(0x24);
  SPI.transfer(0x0B);
  SPI.transfer(0x30);
  SPI.transfer(0x02); 

// number of increments
  SPI.transfer(0x10);
  SPI.transfer(0x64);

// increment interval (NOTE: this is useful only if the AD5932 is programmed to do an automatic sweep, otherwise it is ignored)
  SPI.transfer(0x64);
  SPI.transfer(0xC5);

  SPI.endTransaction();
  SPI.end();

  pinMode(PIN_SYNC, OUTPUT);
  digitalWrite(PIN_SYNC, HIGH);   // raises the SYNC signal to tell the AD5932 that the SPI transfer has finished
}






void setup_UDP_connection()
{
  Serial.println("Setup UDP connection...");
    // 1. Connect to the wifi router and get an IP address.
  WiFi.mode(WIFI_STA);
  WiFi.begin(ssid, password);
  if (WiFi.waitForConnectResult() != WL_CONNECTED) {
    Serial.println("WiFi Failed");
  }
  Serial.println(WiFi.localIP());

  // 2. Connect to the UDP server, hosted on the receiving device
  if (udp.connect(IP_ADDRESS, PORT)) {     // udp.connect(IPAddress(192, 168, 22, 64), PORT) (Blum)
    Serial.println("UDP connected");
    udp.print("Hello server");
    udp.onPacket([](AsyncUDPPacket packet) {
      Serial.print("UDP Packet Type: ");
      Serial.print(packet.isBroadcast() ? "Broadcast" : packet.isMulticast() ? "Multicast" : "Unicast");
      Serial.print(", From: ");
      Serial.print(packet.remoteIP());
      Serial.print(":");
      Serial.print(packet.remotePort());
      Serial.print(", To: ");
      Serial.print(packet.localIP());
      Serial.print(":");
      Serial.print(packet.localPort());
      Serial.print(", Length: ");
      Serial.print(packet.length());
      Serial.print(", Data: ");
      Serial.write(packet.data(), packet.length());
      Serial.println();
      //reply to the client
      packet.printf("Got %u bytes of data", packet.length());
    });
  } else {
    Serial.println("UDP not connecting...");
  }

  // 3. Communication with sever is now allowed
  if (udp_listen.listen(5500)) {
    Serial.println("UDP listenner connected");
    udp_listen.onPacket([](AsyncUDPPacket packet) {
      Serial.print("UDP Packet Type: ");
      Serial.print(packet.isBroadcast() ? "Broadcast" : packet.isMulticast() ? "Multicast" : "Unicast");
      Serial.print(", From: ");
      Serial.print(packet.remoteIP());
      Serial.print(":");
      Serial.print(packet.remotePort());
      Serial.print(", To: ");
      Serial.print(packet.localIP());
      Serial.print(":");
      Serial.print(packet.localPort());
      Serial.print(", Length: ");
      Serial.print(packet.length());
      Serial.print(", Data: ");
      Serial.write(packet.data(), packet.length());
      Serial.println();
      //reply to the client
      String str = (char*) packet.data();
      if (str == "r") {
        // reboot the code here
        resetFunc() ;
      }
    });
  } else {
    Serial.println("UDP not connecting...");
  }
}


String formatToString(float *array, int size, char separator)
{
  String formatted_string = "";
  int i = 0;

  for (i=0; i<size; i++)
  {
    if (i!=0) // shouldn't put separator in the first element!
      formatted_string.concat(separator);
    formatted_string.concat(array[i]);
  }
  return formatted_string;
}
